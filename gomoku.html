<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>五子棋</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
      user-select: none;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      overflow-x: hidden;
      position: relative;
      padding: 10px;
    }
    
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      position: relative;
      z-index: 10;
      width: 100%;
      max-width: 500px;
    }
    
    .game-header {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      gap: 30px;
      flex-wrap: wrap;
    }
    
    .player-info {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 20px;
      padding: 20px 25px;
      text-align: center;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
      flex: 1;
      min-width: 140px;
      max-width: 180px;
      height: 130px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .player-info::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 130px;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .player-info.active::before {
      opacity: 1;
      height: 130px;
    }
    
    .player-info.active {
      background: rgba(102, 126, 234, 0.8);
      box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .player-name {
      font-size: 16px;
      color: #a0a0a0;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 600;
    }
    
    .player-info.active .player-name {
      color: #fff;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .player-piece-display {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    
    .player-piece {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      transition: all 0.3s ease;
    }
    
    .player-piece.white {
      background: radial-gradient(circle at 30% 30%, #fff, #ddd);
      border: 2px solid #ccc;
    }
    
    .player-piece.black {
      background: #000;
      border: 2px solid #333;
    }
    
    .player-info.active .player-piece {
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
    }
    
    .player-status {
      font-size: 12px;
      color: #888;
      font-weight: 500;
    }
    
    .player-info.active .player-status {
      color: #fff;
      font-weight: 600;
    }
    
    .game-board-container {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 15px;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
      padding: 15px;
      position: relative;
      width: 100%;
      max-width: 450px;
    }
    
    #gameBoard {
      width: 100%;
      aspect-ratio: 1;
      background: rgba(139, 69, 19, 0.9);
      border-radius: 8px;
      position: relative;
      padding: 20px;
      cursor: pointer;
    }
    
    .grid-line {
      position: absolute;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1;
    }
    
    .grid-line.horizontal {
      width: calc(100% - 40px);
      height: 2px;
      left: 20px;
    }
    
    .grid-line.vertical {
      width: 2px;
      height: calc(100% - 40px);
      top: 20px;
    }
    
    .intersection {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 2;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: all 0.2s ease;
    }
    
    .intersection:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .piece {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease-in-out;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      animation: placepiece 0.3s ease-out;
      z-index: 3;
    }
    
    .piece.black {
      background: #000;
      border: 2px solid #333;
    }
    
    .piece.white {
      background: radial-gradient(circle at 30% 30%, #fff, #ddd);
      border: 2px solid #ccc;
    }
    
    .piece.winning {
      animation: winning 1s ease-in-out infinite alternate;
    }
    
    @keyframes placepiece {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }
    
    @keyframes winning {
      0% {
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
      }
      100% {
        box-shadow: 0 0 25px rgba(255, 215, 0, 1);
      }
    }
    
    .control-buttons {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .game-btn {
      padding: 15px 30px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 25px;
      font-size: 16px;
      font-weight: bold;
      color: white;
      text-align: center;
      box-shadow: 
        0 8px 25px rgba(102, 126, 234, 0.4),
        inset 0 2px 4px rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
      border: none;
      cursor: pointer;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 1px;
      min-width: 120px;
    }
    
    .game-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }
    
    .game-btn:hover {
      transform: translateY(-3px);
      box-shadow: 
        0 12px 35px rgba(102, 126, 234, 0.6),
        inset 0 2px 4px rgba(255, 255, 255, 0.3);
      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
    }
    
    .game-btn:hover::before {
      left: 100%;
    }
    
    .game-btn:active {
      transform: translateY(-1px) scale(0.98);
    }
    
    .game-result {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      display: none;
    }
    
    .result-content {
      background: rgba(0, 0, 0, 0.8);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      max-width: 90%;
    }
    
    .result-title {
      font-size: 36px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    
    .result-title.win {
      color: #50C878;
    }
    
    .result-title.lose {
      color: #ff4d4d;
    }
    
    .result-title.draw {
      color: #ffa500;
    }
    
    .restart-btn {
      padding: 18px 40px;
      background: linear-gradient(to right, #ff416c, #ff4b2b);
      border-radius: 30px;
      font-size: 20px;
      font-weight: bold;
      color: white;
      box-shadow: 0 8px 25px rgba(255, 75, 43, 0.4);
      border: none;
      cursor: pointer;
      margin-top: 20px;
      transition: all 0.3s ease;
    }
    
    .restart-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 35px rgba(255, 75, 43, 0.6);
    }
    
    /* 背景动画 */
    .background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: 1;
    }
    
    .shape {
      position: absolute;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      animation: float 15s infinite linear;
    }
    
    @keyframes float {
      0% {
        transform: translateY(0) rotate(0deg);
      }
      100% {
        transform: translateY(-100vh) rotate(360deg);
      }
    }
    
    /* 响应式设计 */
    @media (max-width: 480px) {
      .game-container {
        gap: 15px;
        padding: 0 5px;
      }
      
      .game-header {
        gap: 20px;
      }
      
      .player-info {
        padding: 15px 20px;
        min-width: 120px;
      }
      
      .player-name {
        font-size: 14px;
      }
      
      .player-piece {
        width: 28px;
        height: 28px;
      }
      
      .game-board-container {
        padding: 10px;
      }
      
      #gameBoard {
        padding: 15px;
      }
      
      .intersection {
        width: 25px;
        height: 25px;
      }
      
      .piece {
        width: 22px;
        height: 22px;
      }
      
      .game-btn {
        padding: 12px 20px;
        font-size: 14px;
        min-width: 100px;
      }
      
      .result-content {
        padding: 30px 20px;
      }
      
      .result-title {
        font-size: 28px;
      }
    }
  </style>
</head>
<body>
  <div class="background" id="background"></div>
  
  <div class="game-container">
    <!-- 玩家信息 -->
    <div class="game-header">
      <div class="player-info active" id="playerInfo">
        <div class="player-name">玩家</div>
        <div class="player-piece-display">
          <div class="player-piece white"></div>
        </div>
        <div class="player-status">你的回合</div>
      </div>
      
      <div class="player-info" id="aiInfo">
        <div class="player-name">AI</div>
        <div class="player-piece-display">
          <div class="player-piece black"></div>
        </div>
        <div class="player-status">等待中...</div>
      </div>
    </div>
    
    <!-- 游戏棋盘 -->
    <div class="game-board-container">
      <div id="gameBoard"></div>
    </div>
    
    <!-- 控制按钮 -->
    <div class="control-buttons">
      <button class="game-btn" id="newGameBtn">新游戏</button>
    </div>
  </div>
  
  <!-- 游戏结果弹窗 -->
  <div class="game-result" id="gameResult">
    <div class="result-content">
      <div class="result-title" id="resultTitle">游戏结束</div>
      <button class="restart-btn" id="restartBtn">重新开始</button>
    </div>
  </div>

  <script>
    // 游戏状态
    const BOARD_SIZE = 15;
    const EMPTY = 0;
    const PLAYER = 1;
    const AI = 2;
    
    let board = [];
    let currentPlayer = PLAYER;
    let gameEnded = false;
    let moveHistory = [];
    let cellSize = 0;
    
    // AI难度设置
    const AI_DEPTH = 4;
    
    // 智能评分系统
    const SCORES = {
      FIVE: 1000000,        // 连五
      LIVE_FOUR: 100000,    // 活四
      RUSH_FOUR: 50000,     // 冲四
      LIVE_THREE: 10000,    // 活三
      SLEEP_THREE: 1000,    // 眠三
      LIVE_TWO: 500,        // 活二
      SLEEP_TWO: 50,        // 眠二
      ONE: 10               // 单子
    };
    
    // 初始化游戏
    function init() {
      createBackground();
      setupEventListeners();
      newGame();
    }
    
    // 创建动态背景
    function createBackground() {
      const bg = document.getElementById('background');
      const colors = ['rgba(255,255,255,0.05)', 'rgba(255,255,255,0.03)', 'rgba(255,255,255,0.02)'];
      
      for (let i = 0; i < 20; i++) {
        const shape = document.createElement('div');
        shape.classList.add('shape');
        
        const size = Math.random() * 100 + 50;
        shape.style.width = `${size}px`;
        shape.style.height = `${size}px`;
        shape.style.left = `${Math.random() * 100}%`;
        shape.style.top = `${Math.random() * 100}%`;
        shape.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        shape.style.animationDuration = `${Math.random() * 30 + 15}s`;
        shape.style.animationDelay = `${Math.random() * 5}s`;
        
        bg.appendChild(shape);
      }
    }
    
    // 设置事件监听器
    function setupEventListeners() {
      document.getElementById('newGameBtn').addEventListener('click', newGame);
      document.getElementById('restartBtn').addEventListener('click', newGame);
      
      // 窗口大小改变时重新创建棋盘
      window.addEventListener('resize', () => {
        setTimeout(createBoard, 100);
      });
    }
    
    // 新游戏
    function newGame() {
      // 初始化棋盘
      board = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        board[i] = [];
        for (let j = 0; j < BOARD_SIZE; j++) {
          board[i][j] = EMPTY;
        }
      }
      
      currentPlayer = PLAYER;
      gameEnded = false;
      moveHistory = [];
      
      createBoard();
      updatePlayerInfo();
      document.getElementById('gameResult').style.display = 'none';
    }
    
    // 创建棋盘
    function createBoard() {
      const gameBoard = document.getElementById('gameBoard');
      gameBoard.innerHTML = '';
      
      // 等待DOM更新后获取尺寸
      setTimeout(() => {
        const boardRect = gameBoard.getBoundingClientRect();
        
        // 动态获取当前的padding和intersection尺寸
        const computedStyle = window.getComputedStyle(gameBoard);
        const boardPadding = parseInt(computedStyle.paddingLeft);
        
        const intersectionStyle = window.getComputedStyle(document.querySelector('.intersection') || document.createElement('div'));
        const intersectionSize = parseInt(intersectionStyle.width) || (window.innerWidth <= 480 ? 25 : 30);
        const intersectionRadius = intersectionSize / 2;
        
        cellSize = (boardRect.width - boardPadding * 2) / (BOARD_SIZE - 1);
        
        // 创建网格线
        for (let i = 0; i < BOARD_SIZE; i++) {
          // 水平线
          const hLine = document.createElement('div');
          hLine.className = 'grid-line horizontal';
          hLine.style.top = `${boardPadding + i * cellSize}px`;
          gameBoard.appendChild(hLine);
          
          // 垂直线
          const vLine = document.createElement('div');
          vLine.className = 'grid-line vertical';
          vLine.style.left = `${boardPadding + i * cellSize}px`;
          gameBoard.appendChild(vLine);
        }
        
        // 创建交叉点 - 精确对齐到网格线交叉点
        for (let i = 0; i < BOARD_SIZE; i++) {
          for (let j = 0; j < BOARD_SIZE; j++) {
            const intersection = document.createElement('div');
            intersection.className = 'intersection';
            intersection.dataset.row = i;
            intersection.dataset.col = j;
            // 交叉点中心对齐到网格线交叉点 - 使用动态计算的值
            intersection.style.left = `${boardPadding + j * cellSize - intersectionRadius}px`;
            intersection.style.top = `${boardPadding + i * cellSize - intersectionRadius}px`;
            intersection.addEventListener('click', () => handleIntersectionClick(i, j));
            gameBoard.appendChild(intersection);
          }
        }
        
        // 重新渲染已有的棋子
        updateBoard();
      }, 50);
    }
    
    // 处理交叉点点击
    function handleIntersectionClick(row, col) {
      if (gameEnded || currentPlayer !== PLAYER || board[row][col] !== EMPTY) {
        return;
      }
      
      makeMove(row, col, PLAYER);
      
      if (!gameEnded) {
        setTimeout(() => {
          aiMove();
        }, 300);
      }
    }
    
    // 下棋
    function makeMove(row, col, player) {
      board[row][col] = player;
      moveHistory.push({row, col, player});
      
      updateBoard();
      
      if (checkWin(row, col, player)) {
        endGame(player);
        return;
      }
      
      if (isBoardFull()) {
        endGame(0); // 平局
        return;
      }
      
      currentPlayer = currentPlayer === PLAYER ? AI : PLAYER;
      updatePlayerInfo();
    }
    
    // AI下棋 - 智能防守算法
    function aiMove() {
      if (gameEnded || currentPlayer !== AI) return;
      
      const move = getBestMove();
      if (move) {
        makeMove(move.row, move.col, AI);
      }
    }
    
    // 获取最佳移动 - 智能算法
    function getBestMove() {
      // 1. 检查AI是否有必胜位置
      const winMove = findWinningMove(AI);
      if (winMove) return winMove;
      
      // 2. 检查是否需要防守玩家的必胜位置
      const blockMove = findWinningMove(PLAYER);
      if (blockMove) return blockMove;
      
      // 3. 检查AI的活四位置
      const aiFourMove = findPatternMove(AI, SCORES.LIVE_FOUR);
      if (aiFourMove) return aiFourMove;
      
      // 4. 检查需要防守的玩家活四位置
      const blockFourMove = findPatternMove(PLAYER, SCORES.LIVE_FOUR);
      if (blockFourMove) return blockFourMove;
      
      // 5. 检查AI的活三位置
      const aiThreeMove = findPatternMove(AI, SCORES.LIVE_THREE);
      if (aiThreeMove) return aiThreeMove;
      
      // 6. 检查需要防守的玩家活三位置
      const blockThreeMove = findPatternMove(PLAYER, SCORES.LIVE_THREE);
      if (blockThreeMove) return blockThreeMove;
      
      // 7. 如果是第一步，下在中心
      if (moveHistory.length === 0) {
        return {row: Math.floor(BOARD_SIZE / 2), col: Math.floor(BOARD_SIZE / 2)};
      }
      
      // 8. 使用Minimax算法寻找最佳位置
      return minimaxSearch();
    }
    
    // Minimax搜索
    function minimaxSearch() {
      const candidates = getCandidateMoves();
      let bestScore = -Infinity;
      let bestMove = null;
      
      for (const move of candidates) {
        board[move.row][move.col] = AI;
        const score = minimax(AI_DEPTH - 1, -Infinity, Infinity, false);
        board[move.row][move.col] = EMPTY;
        
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }
      
      return bestMove || candidates[0];
    }
    
    // Minimax算法
    function minimax(depth, alpha, beta, isMaximizing) {
      if (depth === 0) {
        return evaluateBoard();
      }
      
      const moves = getCandidateMoves();
      
      if (isMaximizing) {
        let maxScore = -Infinity;
        for (const move of moves) {
          board[move.row][move.col] = AI;
          
          if (checkWin(move.row, move.col, AI)) {
            board[move.row][move.col] = EMPTY;
            return SCORES.FIVE + depth;
          }
          
          const score = minimax(depth - 1, alpha, beta, false);
          board[move.row][move.col] = EMPTY;
          
          maxScore = Math.max(score, maxScore);
          alpha = Math.max(alpha, score);
          if (beta <= alpha) break;
        }
        return maxScore;
      } else {
        let minScore = Infinity;
        for (const move of moves) {
          board[move.row][move.col] = PLAYER;
          
          if (checkWin(move.row, move.col, PLAYER)) {
            board[move.row][move.col] = EMPTY;
            return -SCORES.FIVE - depth;
          }
          
          const score = minimax(depth - 1, alpha, beta, true);
          board[move.row][move.col] = EMPTY;
          
          minScore = Math.min(score, minScore);
          beta = Math.min(beta, score);
          if (beta <= alpha) break;
        }
        return minScore;
      }
    }
    
    // 寻找获胜位置
    function findWinningMove(player) {
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === EMPTY) {
            board[i][j] = player;
            if (checkWin(i, j, player)) {
              board[i][j] = EMPTY;
              return {row: i, col: j};
            }
            board[i][j] = EMPTY;
          }
        }
      }
      return null;
    }
    
    // 寻找特定模式的位置
    function findPatternMove(player, targetScore) {
      const candidates = getCandidateMoves();
      
      for (const move of candidates) {
        const score = evaluatePosition(move.row, move.col, player);
        if (score >= targetScore) {
          return move;
        }
      }
      return null;
    }
    
    // 获取候选移动位置
    function getCandidateMoves() {
      const moves = [];
      const range = 2;
      const checked = new Set();
      
      // 在已有棋子周围寻找候选位置
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] !== EMPTY) {
            for (let di = -range; di <= range; di++) {
              for (let dj = -range; dj <= range; dj++) {
                const ni = i + di;
                const nj = j + dj;
                const key = `${ni},${nj}`;
                
                if (ni >= 0 && ni < BOARD_SIZE && 
                    nj >= 0 && nj < BOARD_SIZE && 
                    board[ni][nj] === EMPTY && 
                    !checked.has(key)) {
                  moves.push({row: ni, col: nj});
                  checked.add(key);
                }
              }
            }
          }
        }
      }
      
      // 如果没有候选位置，返回中心附近的位置
      if (moves.length === 0) {
        const center = Math.floor(BOARD_SIZE / 2);
        for (let i = center - 1; i <= center + 1; i++) {
          for (let j = center - 1; j <= center + 1; j++) {
            if (i >= 0 && i < BOARD_SIZE && j >= 0 && j < BOARD_SIZE && board[i][j] === EMPTY) {
              moves.push({row: i, col: j});
            }
          }
        }
      }
      
      // 按评分排序，优先考虑高分位置
      moves.sort((a, b) => {
        const scoreA = evaluatePosition(a.row, a.col, AI) + evaluatePosition(a.row, a.col, PLAYER);
        const scoreB = evaluatePosition(b.row, b.col, AI) + evaluatePosition(b.row, b.col, PLAYER);
        return scoreB - scoreA;
      });
      
      return moves.slice(0, 15); // 限制候选数量
    }
    
    // 评估棋盘
    function evaluateBoard() {
      let score = 0;
      
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === AI) {
            score += evaluatePosition(i, j, AI);
          } else if (board[i][j] === PLAYER) {
            score -= evaluatePosition(i, j, PLAYER) * 1.1; // 稍微提高防守权重
          }
        }
      }
      
      return score;
    }
    
    // 评估位置得分
    function evaluatePosition(row, col, player) {
      let totalScore = 0;
      const directions = [
        [0, 1],   // 水平
        [1, 0],   // 垂直
        [1, 1],   // 对角线
        [1, -1]   // 反对角线
      ];
      
      for (const [dr, dc] of directions) {
        totalScore += evaluateDirection(row, col, dr, dc, player);
      }
      
      return totalScore;
    }
    
    // 评估方向得分 - 智能模式识别
    function evaluateDirection(row, col, dr, dc, player) {
      const line = getLine(row, col, dr, dc);
      return analyzePattern(line, player);
    }
    
    // 获取直线上的棋子情况
    function getLine(row, col, dr, dc) {
      const line = [];
      
      // 向前扫描4个位置
      for (let i = -4; i <= 4; i++) {
        const r = row + i * dr;
        const c = col + i * dc;
        
        if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {
          line.push('X'); // 边界
        } else {
          line.push(board[r][c]);
        }
      }
      
      return line;
    }
    
    // 分析棋型模式
    function analyzePattern(line, player) {
      const opponent = player === AI ? PLAYER : AI;
      let score = 0;
      
      // 将当前位置设为该玩家的棋子
      line[4] = player;
      
      // 转换为字符串便于模式匹配
      const pattern = line.map(cell => {
        if (cell === player) return 'O';
        if (cell === opponent) return 'X';
        if (cell === EMPTY) return '_';
        return 'B'; // 边界
      }).join('');
      
      // 连五
      if (pattern.includes('OOOOO')) {
        score += SCORES.FIVE;
      }
      
      // 活四
      if (pattern.includes('_OOOO_')) {
        score += SCORES.LIVE_FOUR;
      }
      
      // 冲四
      if (pattern.includes('XOOOO_') || pattern.includes('_OOOOX') || 
          pattern.includes('BOOOO_') || pattern.includes('_OOOOB')) {
        score += SCORES.RUSH_FOUR;
      }
      
      // 活三
      if (pattern.includes('_OOO_') || pattern.includes('_O_OO_') || pattern.includes('_OO_O_')) {
        score += SCORES.LIVE_THREE;
      }
      
      // 眠三
      if (pattern.includes('XOOO_') || pattern.includes('_OOOX') ||
          pattern.includes('XOO_O') || pattern.includes('O_OOX') ||
          pattern.includes('BOOO_') || pattern.includes('_OOOB')) {
        score += SCORES.SLEEP_THREE;
      }
      
      // 活二
      if (pattern.includes('_OO_') || pattern.includes('_O_O_')) {
        score += SCORES.LIVE_TWO;
      }
      
      // 眠二
      if (pattern.includes('XOO_') || pattern.includes('_OOXX') ||
          pattern.includes('XO_O') || pattern.includes('O_OX') ||
          pattern.includes('BOO_') || pattern.includes('_OOBB')) {
        score += SCORES.SLEEP_TWO;
      }
      
      // 单子
      if (pattern.includes('_O_')) {
        score += SCORES.ONE;
      }
      
      return score;
    }
    
    // 检查获胜
    function checkWin(row, col, player) {
      const directions = [
        [0, 1],   // 水平
        [1, 0],   // 垂直
        [1, 1],   // 对角线
        [1, -1]   // 反对角线
      ];
      
      for (const [dr, dc] of directions) {
        let count = 1;
        
        // 向前计数
        let r = row + dr;
        let c = col + dc;
        while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
          count++;
          r += dr;
          c += dc;
        }
        
        // 向后计数
        r = row - dr;
        c = col - dc;
        while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
          count++;
          r -= dr;
          c -= dc;
        }
        
        if (count >= 5) {
          highlightWinningPieces(row, col, dr, dc, player);
          return true;
        }
      }
      
      return false;
    }
    
    // 高亮获胜棋子
    function highlightWinningPieces(row, col, dr, dc, player) {
      const pieces = [{row, col}];
      
      // 向前收集
      let r = row + dr;
      let c = col + dc;
      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
        pieces.push({row: r, col: c});
        r += dr;
        c += dc;
      }
      
      // 向后收集
      r = row - dr;
      c = col - dc;
      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
        pieces.push({row: r, col: c});
        r -= dr;
        c -= dc;
      }
      
      // 高亮前5个棋子
      for (let i = 0; i < Math.min(5, pieces.length); i++) {
        const piece = pieces[i];
        const pieceElement = document.querySelector(`[data-row="${piece.row}"][data-col="${piece.col}"] .piece`);
        if (pieceElement) {
          pieceElement.classList.add('winning');
        }
      }
    }
    
    // 检查棋盘是否满了
    function isBoardFull() {
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === EMPTY) {
            return false;
          }
        }
      }
      return true;
    }
    
    // 更新棋盘显示
    function updateBoard() {
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          const intersection = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
          if (!intersection) continue;
          
          const existingPiece = intersection.querySelector('.piece');
          
          if (board[i][j] !== EMPTY && !existingPiece) {
            const piece = document.createElement('div');
            piece.className = `piece ${board[i][j] === PLAYER ? 'white' : 'black'}`;
            intersection.appendChild(piece);
          } else if (board[i][j] === EMPTY && existingPiece) {
            existingPiece.remove();
          }
        }
      }
    }
    
    // 更新玩家信息
    function updatePlayerInfo() {
      const playerInfo = document.getElementById('playerInfo');
      const aiInfo = document.getElementById('aiInfo');
      const playerStatus = playerInfo.querySelector('.player-status');
      const aiStatus = aiInfo.querySelector('.player-status');
      
      if (currentPlayer === PLAYER) {
        playerInfo.classList.add('active');
        aiInfo.classList.remove('active');
        playerStatus.textContent = '你的回合';
        aiStatus.textContent = '等待中...';
      } else {
        playerInfo.classList.remove('active');
        aiInfo.classList.add('active');
        playerStatus.textContent = '等待中...';
        aiStatus.textContent = 'AI思考中...';
      }
    }
    
    // 结束游戏
    function endGame(winner) {
      gameEnded = true;
      const resultTitle = document.getElementById('resultTitle');
      
      if (winner === PLAYER) {
        resultTitle.textContent = '恭喜！你赢了！';
        resultTitle.className = 'result-title win';
      } else if (winner === AI) {
        resultTitle.textContent = 'AI获胜！';
        resultTitle.className = 'result-title lose';
      } else {
        resultTitle.textContent = '平局！';
        resultTitle.className = 'result-title draw';
      }
      
      // 更新状态显示
      const playerStatus = document.getElementById('playerInfo').querySelector('.player-status');
      const aiStatus = document.getElementById('aiInfo').querySelector('.player-status');
      
      if (winner === PLAYER) {
        playerStatus.textContent = '获胜！';
        aiStatus.textContent = '失败';
      } else if (winner === AI) {
        playerStatus.textContent = '失败';
        aiStatus.textContent = '获胜！';
      } else {
        playerStatus.textContent = '平局';
        aiStatus.textContent = '平局';
      }
      
      setTimeout(() => {
        document.getElementById('gameResult').style.display = 'flex';
      }, 1000);
    }
    
    // 页面加载完成后初始化
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>