[
  {
    "isPinned" : true,
    "html" : "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n  <title>移动端俄罗斯方块<\/title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n      box-sizing: border-box;\n      touch-action: manipulation;\n      user-select: none;\n    }\n    \n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);\n      height: 100vh;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      color: white;\n      overflow: hidden;\n      position: relative;\n    }\n    \n    .game-container {\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      gap: 20px;\n      position: relative;\n      z-index: 10;\n    }\n    \n    .main-content {\n      display: flex;\n      gap: 20px;\n      align-items: flex-start;\n    }\n    \n    .left-section {\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n    }\n    \n    .game-board {\n      background: rgba(0, 0, 0, 0.6);\n      border-radius: 10px;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);\n      overflow: hidden;\n      position: relative;\n    }\n    \n    #tetris {\n      display: block;\n    }\n    \n    \/* 开始按钮覆盖层 *\/\n    .start-overlay {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background: rgba(0, 0, 0, 0.8);\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      z-index: 15;\n      border-radius: 10px;\n    }\n    \n    .start-overlay.hidden {\n      display: none;\n    }\n    \n    .start-btn {\n      padding: 20px 40px;\n      background: linear-gradient(to right, #50C878, #32CD32);\n      border-radius: 25px;\n      font-size: 24px;\n      font-weight: bold;\n      color: white;\n      text-align: center;\n      box-shadow: \n        0 8px 25px rgba(80, 200, 120, 0.4),\n        inset 0 2px 4px rgba(255, 255, 255, 0.2);\n      transition: all 0.2s ease;\n      border: none;\n      cursor: pointer;\n      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    }\n    \n    .start-btn:hover {\n      transform: translateY(-2px);\n      box-shadow: \n        0 12px 30px rgba(80, 200, 120, 0.5),\n        inset 0 2px 4px rgba(255, 255, 255, 0.2);\n    }\n    \n    .start-btn:active {\n      transform: scale(0.95);\n      box-shadow: \n        0 4px 15px rgba(80, 200, 120, 0.3),\n        inset 0 1px 2px rgba(255, 255, 255, 0.1);\n    }\n    \n    .controls {\n      display: flex;\n      gap: 15px;\n      align-items: center;\n      justify-content: center;\n    }\n    \n    .control-btn {\n      width: 70px;\n      height: 70px;\n      background: rgba(255, 255, 255, 0.15);\n      border-radius: 20px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      font-size: 32px;\n      color: white;\n      box-shadow: \n        0 5px 15px rgba(0, 0, 0, 0.3),\n        inset 0 2px 4px rgba(255, 255, 255, 0.1);\n      transition: all 0.1s ease;\n      border: 1px solid rgba(255, 255, 255, 0.1);\n      backdrop-filter: blur(5px);\n      cursor: pointer;\n    }\n    \n    .control-btn:active {\n      transform: scale(0.95);\n      background: rgba(255, 255, 255, 0.25);\n      box-shadow: \n        0 2px 8px rgba(0, 0, 0, 0.2),\n        inset 0 1px 2px rgba(255, 255, 255, 0.2);\n    }\n    \n    .rotate-btn {\n      background: rgba(255, 215, 0, 0.25);\n    }\n    \n    .down-btn {\n      background: rgba(0, 191, 255, 0.25);\n    }\n    \n    .right-section {\n      display: flex;\n      flex-direction: column;\n      gap: 15px;\n      min-width: 120px;\n    }\n    \n    .info-box {\n      background: rgba(0, 0, 0, 0.5);\n      border-radius: 10px;\n      padding: 15px;\n      text-align: center;\n      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);\n    }\n    \n    .info-title {\n      font-size: 14px;\n      color: #a0a0a0;\n      margin-bottom: 8px;\n    }\n    \n    .info-value {\n      font-size: 24px;\n      font-weight: bold;\n      color: #fff;\n    }\n    \n    .next-piece-container {\n      background: rgba(0, 0, 0, 0.6);\n      border-radius: 10px;\n      padding: 15px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);\n    }\n    \n    .next-title {\n      font-size: 14px;\n      color: #a0a0a0;\n      margin-bottom: 10px;\n      text-align: center;\n    }\n    \n    #nextPiece {\n      width: 80px;\n      height: 80px;\n    }\n    \n    .game-over {\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background: rgba(0, 0, 0, 0.85);\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      z-index: 20;\n      display: none;\n    }\n    \n    .game-over h2 {\n      font-size: 48px;\n      color: #ff4d4d;\n      margin-bottom: 30px;\n      text-shadow: 0 0 10px rgba(255, 77, 77, 0.5);\n    }\n    \n    .final-score {\n      font-size: 32px;\n      margin-bottom: 30px;\n    }\n    \n    .restart-btn {\n      padding: 18px 50px;\n      background: linear-gradient(to right, #ff416c, #ff4b2b);\n      border-radius: 30px;\n      font-size: 22px;\n      font-weight: bold;\n      color: white;\n      box-shadow: 0 8px 25px rgba(255, 75, 43, 0.4);\n      border: none;\n      cursor: pointer;\n    }\n    \n    \/* 背景动画 *\/\n    .background {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      overflow: hidden;\n      z-index: 1;\n    }\n    \n    .shape {\n      position: absolute;\n      background: rgba(255, 255, 255, 0.03);\n      border: 1px solid rgba(255, 255, 255, 0.05);\n      border-radius: 10px;\n      animation: float 15s infinite linear;\n    }\n    \n    @keyframes float {\n      0% {\n        transform: translateY(0) rotate(0deg);\n      }\n      100% {\n        transform: translateY(-100vh) rotate(360deg);\n      }\n    }\n  <\/style>\n<\/head>\n<body>\n  <div class=\"background\" id=\"background\"><\/div>\n  \n  <div class=\"game-container\">\n    <div class=\"main-content\">\n      <div class=\"left-section\">\n        <div class=\"game-board\">\n          <canvas id=\"tetris\"><\/canvas>\n          <!-- 开始按钮覆盖层 -->\n          <div class=\"start-overlay\" id=\"startOverlay\">\n            <button class=\"start-btn\" id=\"startBtn\">开始游戏<\/button>\n          <\/div>\n        <\/div>\n      <\/div>\n      \n      <div class=\"right-section\">\n        <div class=\"info-box\">\n          <div class=\"info-title\">分数<\/div>\n          <div class=\"info-value\" id=\"score\">0<\/div>\n        <\/div>\n        \n        <div class=\"info-box\">\n          <div class=\"info-title\">最高分<\/div>\n          <div class=\"info-value\" id=\"highScore\">0<\/div>\n        <\/div>\n        \n        <div class=\"info-box\">\n          <div class=\"info-title\">等级<\/div>\n          <div class=\"info-value\" id=\"level\">1<\/div>\n        <\/div>\n        \n        <div class=\"next-piece-container\">\n          <div>\n            <div class=\"next-title\">下一个<\/div>\n            <canvas id=\"nextPiece\"><\/canvas>\n          <\/div>\n        <\/div>\n      <\/div>\n    <\/div>\n    \n    <!-- 控制按钮移到底部 -->\n    <div class=\"controls\">\n      <div class=\"control-btn\" id=\"leftBtn\">←<\/div>\n      <div class=\"control-btn down-btn\" id=\"downBtn\">↓<\/div>\n      <div class=\"control-btn\" id=\"rightBtn\">→<\/div>\n      <div class=\"control-btn rotate-btn\" id=\"rotateBtn\">↻<\/div>\n    <\/div>\n  <\/div>\n  \n  <div class=\"game-over\" id=\"gameOver\">\n    <h2>游戏结束!<\/h2>\n    <div class=\"final-score\">分数: <span id=\"finalScore\">0<\/span><\/div>\n    <button class=\"restart-btn\" id=\"restartBtn\">重新开始<\/button>\n  <\/div>\n\n  <script>\n    \/\/ 游戏常量\n    const COLS = 10;\n    const ROWS = 20;\n    const BLOCK_SIZE = 25;\n    const COLORS = [\n      null,\n      '#FF5252', \/\/ I\n      '#FFD740', \/\/ J\n      '#69F0AE', \/\/ L\n      '#448AFF', \/\/ O\n      '#E040FB', \/\/ S\n      '#18FFFF', \/\/ T\n      '#FFAB40'  \/\/ Z\n    ];\n    \n    \/\/ 方块形状定义\n    const SHAPES = [\n      \/\/ I\n      [\n        [0, 0, 0, 0],\n        [1, 1, 1, 1],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]\n      ],\n      \/\/ J\n      [\n        [2, 0, 0],\n        [2, 2, 2],\n        [0, 0, 0]\n      ],\n      \/\/ L\n      [\n        [0, 0, 3],\n        [3, 3, 3],\n        [0, 0, 0]\n      ],\n      \/\/ O\n      [\n        [4, 4],\n        [4, 4]\n      ],\n      \/\/ S\n      [\n        [0, 5, 5],\n        [5, 5, 0],\n        [0, 0, 0]\n      ],\n      \/\/ T\n      [\n        [0, 6, 0],\n        [6, 6, 6],\n        [0, 0, 0]\n      ],\n      \/\/ Z\n      [\n        [7, 7, 0],\n        [0, 7, 7],\n        [0, 0, 0]\n      ]\n    ];\n    \n    \/\/ 游戏变量\n    let canvas, ctx;\n    let nextCanvas, nextCtx;\n    let board = [];\n    let score = 0;\n    let highScore = 0;\n    let level = 1;\n    let lines = 0;\n    let gameOver = false;\n    let gameStarted = false;\n    let dropCounter = 0;\n    let dropInterval = 1000;\n    let lastTime = 0;\n    let player = {\n      pos: {x: 0, y: 0},\n      matrix: null,\n      next: null\n    };\n    \n    \/\/ 初始化游戏\n    function init() {\n      createBackground();\n      \n      canvas = document.getElementById('tetris');\n      ctx = canvas.getContext('2d');\n      \n      \/\/ 根据块大小计算画布大小\n      canvas.width = COLS * BLOCK_SIZE;\n      canvas.height = ROWS * BLOCK_SIZE;\n      \n      \/\/ 初始化下一个方块画布\n      nextCanvas = document.getElementById('nextPiece');\n      nextCtx = nextCanvas.getContext('2d');\n      nextCanvas.width = 80;\n      nextCanvas.height = 80;\n      \n      \/\/ 初始化游戏板\n      createBoard();\n      \n      \/\/ 重置游戏状态\n      resetGame();\n      \n      \/\/ 加载最高分\n      loadHighScore();\n      \n      \/\/ 设置事件监听器\n      setupEventListeners();\n      \n      \/\/ 开始游戏循环\n      requestAnimationFrame(update);\n    }\n    \n    \/\/ 创建动态背景\n    function createBackground() {\n      const bg = document.getElementById('background');\n      const colors = ['rgba(255,255,255,0.05)', 'rgba(255,255,255,0.03)', 'rgba(255,255,255,0.02)'];\n      const shapes = ['square', 'square', 'square', 'square', 'square'];\n      \n      for (let i = 0; i < 20; i++) {\n        const shape = document.createElement('div');\n        shape.classList.add('shape');\n        \n        \/\/ 随机大小\n        const size = Math.random() * 100 + 50;\n        shape.style.width = `${size}px`;\n        shape.style.height = `${size}px`;\n        \n        \/\/ 随机位置\n        shape.style.left = `${Math.random() * 100}%`;\n        shape.style.top = `${Math.random() * 100}%`;\n        \n        \/\/ 随机颜色\n        shape.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];\n        \n        \/\/ 随机形状\n        if (shapes[Math.floor(Math.random() * shapes.length)] === 'circle') {\n          shape.style.borderRadius = '50%';\n        }\n        \n        \/\/ 随机动画\n        shape.style.animationDuration = `${Math.random() * 30 + 15}s`;\n        shape.style.animationDelay = `${Math.random() * 5}s`;\n        \n        bg.appendChild(shape);\n      }\n    }\n    \n    \/\/ 创建游戏板\n    function createBoard() {\n      board = [];\n      for (let y = 0; y < ROWS; y++) {\n        board.push(new Array(COLS).fill(0));\n      }\n    }\n    \n    \/\/ 重置游戏\n    function resetGame() {\n      score = 0;\n      level = 1;\n      lines = 0;\n      gameOver = false;\n      gameStarted = false;\n      dropInterval = 1000; \/\/ 初始下落间隔1000ms\n      document.getElementById('score').textContent = score;\n      document.getElementById('level').textContent = level;\n      document.getElementById('gameOver').style.display = 'none';\n      document.getElementById('startOverlay').classList.remove('hidden');\n      \n      createBoard();\n      resetPlayer();\n    }\n    \n    \/\/ 开始游戏\n    function startGame() {\n      gameStarted = true;\n      document.getElementById('startOverlay').classList.add('hidden');\n      resetPlayer();\n    }\n    \n    \/\/ 重置玩家\n    function resetPlayer() {\n      const pieces = 'ILJOTSZ';\n      \n      if (player && player.next) {\n        \/\/ 使用之前预生成的下一个方块作为当前方块\n        player.matrix = player.next;\n        player.pos = {x: Math.floor(COLS \/ 2) - 1, y: 0};\n        \/\/ 生成新的下一个方块\n        player.next = createPiece(pieces[pieces.length * Math.random() | 0]);\n      } else {\n        \/\/ 初始化时生成两个方块\n        player = {\n          pos: {x: Math.floor(COLS \/ 2) - 1, y: 0},\n          matrix: createPiece(pieces[pieces.length * Math.random() | 0]),\n          next: createPiece(pieces[pieces.length * Math.random() | 0])\n        };\n      }\n      \n      \/\/ 确保新方块不会立即与已有方块碰撞\n      if (gameStarted && collide(board, player)) {\n        player.pos.y = 0;\n        if (collide(board, player)) {\n          gameOver = true;\n          gameStarted = false;\n          document.getElementById('gameOver').style.display = 'flex';\n          document.getElementById('finalScore').textContent = score;\n          \n          \/\/ 更新最高分\n          if (score > highScore) {\n            highScore = score;\n            document.getElementById('highScore').textContent = highScore;\n            saveHighScore();\n          }\n          return;\n        }\n      }\n      \n      drawNextPiece();\n    }\n    \n    \/\/ 创建方块\n    function createPiece(type) {\n      switch (type) {\n        case 'I': return SHAPES[0];\n        case 'J': return SHAPES[1];\n        case 'L': return SHAPES[2];\n        case 'O': return SHAPES[3];\n        case 'S': return SHAPES[4];\n        case 'T': return SHAPES[5];\n        case 'Z': return SHAPES[6];\n      }\n    }\n    \n    \/\/ 绘制游戏板\n    function drawBoard() {\n      \/\/ 绘制背景\n      ctx.fillStyle = 'rgba(10, 15, 40, 0.9)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      \n      \/\/ 绘制网格\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';\n      ctx.lineWidth = 0.5;\n      \n      for (let x = 0; x <= COLS; x++) {\n        ctx.beginPath();\n        ctx.moveTo(x * BLOCK_SIZE, 0);\n        ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);\n        ctx.stroke();\n      }\n      \n      for (let y = 0; y <= ROWS; y++) {\n        ctx.beginPath();\n        ctx.moveTo(0, y * BLOCK_SIZE);\n        ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);\n        ctx.stroke();\n      }\n      \n      drawMatrix(board, {x: 0, y: 0});\n      if (player.matrix && gameStarted) {\n        \/\/ 确保使用BLOCK_SIZE将网格坐标转换为像素坐标\n        drawMatrix(player.matrix, {\n          x: player.pos.x * BLOCK_SIZE, \n          y: player.pos.y * BLOCK_SIZE\n        });\n      }\n    }\n    \n    \/\/ 绘制矩阵\n    function drawMatrix(matrix, offset, context = ctx, blockSize = BLOCK_SIZE) {\n      matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value !== 0) {\n            context.fillStyle = COLORS[value];\n            \/\/ 当传入的offset已经是像素坐标时，直接使用\n            \/\/ 当传入的offset是网格坐标时，需要乘以blockSize\n            const pixelX = offset.x + x * blockSize;\n            const pixelY = offset.y + y * blockSize;\n            \n            context.fillRect(\n              pixelX,\n              pixelY,\n              blockSize - 1,\n              blockSize - 1\n            );\n            \n            \/\/ 添加方块内部高光效果\n            context.fillStyle = 'rgba(255, 255, 255, 0.3)';\n            context.fillRect(\n              pixelX,\n              pixelY,\n              blockSize - 1,\n              blockSize \/ 6\n            );\n            \n            context.fillRect(\n              pixelX,\n              pixelY,\n              blockSize \/ 6,\n              blockSize - 1\n            );\n            \n            \/\/ 添加方块阴影\n            context.fillStyle = 'rgba(0, 0, 0, 0.3)';\n            context.fillRect(\n              pixelX + blockSize - blockSize \/ 6,\n              pixelY + blockSize \/ 6,\n              blockSize \/ 6,\n              blockSize - blockSize \/ 6\n            );\n            \n            context.fillRect(\n              pixelX + blockSize \/ 6,\n              pixelY + blockSize - blockSize \/ 6,\n              blockSize - blockSize \/ 6,\n              blockSize \/ 6\n            );\n          }\n        });\n      });\n    }\n    \n    \/\/ 碰撞检测\n    function collide(board, player) {\n      const [m, o] = [player.matrix, player.pos];\n      for (let y = 0; y < m.length; y++) {\n        for (let x = 0; x < m[y].length; x++) {\n          if (m[y][x] !== 0 &&\n              (board[y + o.y] &&\n              board[y + o.y][x + o.x]) !== 0) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    \n    \/\/ 检查边界碰撞\n    function isValidPosition(board, player, newPos) {\n      const [m] = [player.matrix];\n      for (let y = 0; y < m.length; y++) {\n        for (let x = 0; x < m[y].length; x++) {\n          if (m[y][x] !== 0) {\n            const newX = newPos.x + x;\n            const newY = newPos.y + y;\n            \n            \/\/ 检查边界\n            if (newX < 0 || newX >= COLS || newY >= ROWS) {\n              return false;\n            }\n            \n            \/\/ 检查与已有方块的碰撞\n            if (newY >= 0 && board[newY][newX] !== 0) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    }\n    \n    \/\/ 玩家移动\n    function playerMove(dir) {\n      if (!gameStarted || gameOver) return;\n      \n      const newPos = {\n        x: player.pos.x + dir,\n        y: player.pos.y\n      };\n      \n      if (isValidPosition(board, player, newPos)) {\n        player.pos.x = newPos.x;\n      }\n    }\n    \n    \/\/ 玩家下落\n    function playerDrop() {\n      if (!gameStarted || gameOver) return;\n      \n      const newPos = {\n        x: player.pos.x,\n        y: player.pos.y + 1\n      };\n      \n      if (isValidPosition(board, player, newPos)) {\n        player.pos.y = newPos.y;\n      } else {\n        merge(board, player);\n        arenaSweep();\n        resetPlayer();\n      }\n      dropCounter = 0;\n    }\n    \n    \/\/ 玩家旋转\n    function playerRotate(dir) {\n      if (!gameStarted || gameOver) return;\n      \n      const originalMatrix = player.matrix.map(row => [...row]);\n      const originalPos = {...player.pos};\n      \n      rotate(player.matrix, dir);\n      \n      \/\/ 尝试在当前位置旋转\n      if (isValidPosition(board, player, player.pos)) {\n        return; \/\/ 旋转成功\n      }\n      \n      \/\/ 尝试向左右移动来适应旋转\n      for (let offset = 1; offset <= player.matrix[0].length; offset++) {\n        \/\/ 尝试向右移动\n        const rightPos = {x: originalPos.x + offset, y: originalPos.y};\n        if (isValidPosition(board, player, rightPos)) {\n          player.pos = rightPos;\n          return;\n        }\n        \n        \/\/ 尝试向左移动\n        const leftPos = {x: originalPos.x - offset, y: originalPos.y};\n        if (isValidPosition(board, player, leftPos)) {\n          player.pos = leftPos;\n          return;\n        }\n      }\n      \n      \/\/ 如果无法旋转，恢复原状\n      player.matrix = originalMatrix;\n      player.pos = originalPos;\n    }\n    \n    \/\/ 绘制下一个方块\n    function drawNextPiece() {\n      nextCtx.fillStyle = 'rgba(10, 15, 40, 0.7)';\n      nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);\n      \n      if (player.next) {\n        \/\/ 居中绘制下一个方块\n        const blockSize = 15;\n        const offsetX = (nextCanvas.width - player.next[0].length * blockSize) \/ 2;\n        const offsetY = (nextCanvas.height - player.next.length * blockSize) \/ 2;\n        \n        drawMatrix(player.next, {x: offsetX, y: offsetY}, nextCtx, blockSize);\n      }\n    }\n    \n    \/\/ 绘制矩阵\n    function drawMatrix(matrix, offset, context = ctx, blockSize = BLOCK_SIZE) {\n      matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value !== 0) {\n            context.fillStyle = COLORS[value];\n            context.fillRect(\n              offset.x + x * blockSize,\n              offset.y + y * blockSize,\n              blockSize - 1,\n              blockSize - 1\n            );\n            \n            \/\/ 添加方块内部高光效果\n            context.fillStyle = 'rgba(255, 255, 255, 0.3)';\n            context.fillRect(\n              offset.x + x * blockSize,\n              offset.y + y * blockSize,\n              blockSize - 1,\n              blockSize \/ 6\n            );\n            \n            context.fillRect(\n              offset.x + x * blockSize,\n              offset.y + y * blockSize,\n              blockSize \/ 6,\n              blockSize - 1\n            );\n            \n            \/\/ 添加方块阴影\n            context.fillStyle = 'rgba(0, 0, 0, 0.3)';\n            context.fillRect(\n              offset.x + x * blockSize + blockSize - blockSize \/ 6,\n              offset.y + y * blockSize + blockSize \/ 6,\n              blockSize \/ 6,\n              blockSize - blockSize \/ 6\n            );\n            \n            context.fillRect(\n              offset.x + x * blockSize + blockSize \/ 6,\n              offset.y + y * blockSize + blockSize - blockSize \/ 6,\n              blockSize - blockSize \/ 6,\n              blockSize \/ 6\n            );\n          }\n        });\n      });\n    }\n    \n    \/\/ 合并矩阵\n    function merge(board, player) {\n      player.matrix.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value !== 0) {\n            board[y + player.pos.y][x + player.pos.x] = value;\n          }\n        });\n      });\n    }\n    \n    \/\/ 旋转矩阵\n    function rotate(matrix, dir) {\n      for (let y = 0; y < matrix.length; y++) {\n        for (let x = 0; x < y; x++) {\n          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];\n        }\n      }\n      \n      if (dir > 0) {\n        matrix.forEach(row => row.reverse());\n      } else {\n        matrix.reverse();\n      }\n    }\n    \n    \/\/ 扫描并清除完整的行\n    function arenaSweep() {\n      let rowCount = 0;\n      outer: for (let y = board.length - 1; y > 0; y--) {\n        for (let x = 0; x < board[y].length; x++) {\n          if (board[y][x] === 0) {\n            continue outer;\n          }\n        }\n        \n        const row = board.splice(y, 1)[0].fill(0);\n        board.unshift(row);\n        y++;\n        \n        rowCount++;\n      }\n      \n      if (rowCount > 0) {\n        lines += rowCount;\n        \/\/ 每10行升一级\n        level = Math.floor(lines \/ 10) + 1;\n        \/\/ 修改下落间隔计算：每级缩短10%\n        \/\/ 初始间隔1000ms，每级乘以0.9，最小间隔50ms\n        dropInterval = Math.max(50, 1000 * Math.pow(0.9, level - 1));\n        \n        document.getElementById('level').textContent = level;\n        \n        \/\/ 直接在这里计算并更新分数\n        updateScore(rowCount);\n      }\n    }\n    \n    \/\/ 更新分数\n    function updateScore(clearedLines = 0) {\n      if (clearedLines > 0) {\n        \/\/ 优化后的消除行数得分规则\n        \/\/ 基础分数更加平衡，鼓励多行消除但差距不会太大\n        const linePoints = [0, 10, 24, 40, 60];\n        \n        \/\/ 计算基础分数\n        let basePoints = linePoints[Math.min(clearedLines, 4)];\n        \n        \/\/ 添加连击奖励（同时消除多行的额外奖励）\n        let comboBonus = 0;\n        if (clearedLines >= 2) {\n          comboBonus = (clearedLines - 1) * 10; \/\/ 2行+10，3行+20，4行+30\n        }\n        \n        \/\/ 总分数 = (基础分数 + 连击奖励) × 等级\n        const totalPoints = (basePoints + comboBonus) * level;\n        \n        score += totalPoints;\n        document.getElementById('score').textContent = score;\n        \n        \/\/ 显示得分提示（可选，增强用户体验）\n        showScorePopup(totalPoints, clearedLines);\n        \n        \/\/ 更新最高分\n        if (score > highScore) {\n          highScore = score;\n          document.getElementById('highScore').textContent = highScore;\n          saveHighScore();\n        }\n      }\n    }\n    \n    \/\/ 显示得分提示\n    function showScorePopup(points, lines) {\n      \/\/ 创建得分提示元素\n      const popup = document.createElement('div');\n      popup.style.cssText = `\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        background: rgba(255, 215, 0, 0.9);\n        color: #000;\n        padding: 10px 20px;\n        border-radius: 10px;\n        font-size: 18px;\n        font-weight: bold;\n        z-index: 1000;\n        pointer-events: none;\n        animation: scorePopup 1.5s ease-out forwards;\n      `;\n      \n      \/\/ 根据消除行数显示不同的文本\n      let text = '';\n      switch(lines) {\n        case 1: text = `单行消除 +${points}`; break;\n        case 2: text = `双行消除 +${points}`; break;\n        case 3: text = `三行消除 +${points}`; break;\n        case 4: text = `四行消除 +${points}`; break;\n        default: text = `+${points}`;\n      }\n      \n      popup.textContent = text;\n      \n      \/\/ 添加CSS动画\n      if (!document.querySelector('#scorePopupStyle')) {\n        const style = document.createElement('style');\n        style.id = 'scorePopupStyle';\n        style.textContent = `\n          @keyframes scorePopup {\n            0% {\n              opacity: 0;\n              transform: translate(-50%, -50%) scale(0.5);\n            }\n            30% {\n              opacity: 1;\n              transform: translate(-50%, -50%) scale(1.2);\n            }\n            70% {\n              opacity: 1;\n              transform: translate(-50%, -50%) scale(1);\n            }\n            100% {\n              opacity: 0;\n              transform: translate(-50%, -70%) scale(1);\n            }\n          }\n        `;\n        document.head.appendChild(style);\n      }\n      \n      \/\/ 添加到游戏容器\n      const gameContainer = document.querySelector('.game-container');\n      gameContainer.appendChild(popup);\n      \n      \/\/ 1.5秒后移除\n      setTimeout(() => {\n        if (popup.parentNode) {\n          popup.parentNode.removeChild(popup);\n        }\n      }, 1500);\n    }\n    \n    \/\/ 加载最高分\n    function loadHighScore() {\n      const savedHighScore = localStorage.getItem('tetrisHighScore');\n      if (savedHighScore) {\n        highScore = parseInt(savedHighScore);\n        document.getElementById('highScore').textContent = highScore;\n      }\n    }\n    \n    \/\/ 保存最高分\n    function saveHighScore() {\n      localStorage.setItem('tetrisHighScore', highScore);\n    }\n    \n    \/\/ 更新游戏状态\n    function update(time = 0) {\n      const deltaTime = time - lastTime;\n      lastTime = time;\n      \n      if (gameStarted && !gameOver) {\n        dropCounter += deltaTime;\n        if (dropCounter > dropInterval) {\n          playerDrop();\n        }\n      }\n      \n      drawBoard();\n      requestAnimationFrame(update);\n    }\n    \n    \/\/ 长按相关变量\n    let downBtnPressTimer = null;\n    let isDownBtnPressed = false;\n    let fastDropInterval = null;\n    \n    \/\/ 键盘控制相关变量\n    let keyPressed = {};\n    let keyRepeatTimer = {};\n    \n    \/\/ 快速下落函数\n    function startFastDrop() {\n      if (fastDropInterval) return; \/\/ 防止重复启动\n      \n      fastDropInterval = setInterval(() => {\n        if (gameStarted && !gameOver && isDownBtnPressed) {\n          playerDrop();\n        } else {\n          stopFastDrop();\n        }\n      }, 50); \/\/ 每50ms下落一次，实现快速下落\n    }\n    \n    \/\/ 停止快速下落\n    function stopFastDrop() {\n      if (fastDropInterval) {\n        clearInterval(fastDropInterval);\n        fastDropInterval = null;\n      }\n    }\n    \n    \/\/ 处理键盘按下事件\n    function handleKeyDown(e) {\n      \/\/ 防止重复触发\n      if (keyPressed[e.code]) return;\n      \n      keyPressed[e.code] = true;\n      \n      switch(e.code) {\n        case 'ArrowLeft':\n          e.preventDefault();\n          playerMove(-1);\n          \/\/ 设置重复移动\n          keyRepeatTimer[e.code] = setTimeout(() => {\n            startKeyRepeat(e.code, () => playerMove(-1));\n          }, 200); \/\/ 200ms后开始重复\n          break;\n          \n        case 'ArrowRight':\n          e.preventDefault();\n          playerMove(1);\n          \/\/ 设置重复移动\n          keyRepeatTimer[e.code] = setTimeout(() => {\n            startKeyRepeat(e.code, () => playerMove(1));\n          }, 200);\n          break;\n          \n        case 'ArrowDown':\n          e.preventDefault();\n          \/\/ 模拟长按下落按钮\n          if (!isDownBtnPressed) {\n            isDownBtnPressed = true;\n            playerDrop();\n            downBtnPressTimer = setTimeout(() => {\n              startFastDrop();\n            }, 1000);\n          }\n          break;\n          \n        case 'ArrowUp':\n        case 'Space':\n          e.preventDefault();\n          playerRotate(1);\n          break;\n          \n        case 'Enter':\n          e.preventDefault();\n          if (!gameStarted && !gameOver) {\n            startGame();\n          } else if (gameOver) {\n            resetGame();\n          }\n          break;\n          \n        case 'KeyR':\n          e.preventDefault();\n          if (gameOver) {\n            resetGame();\n          }\n          break;\n          \n        case 'KeyP':\n          e.preventDefault();\n          \/\/ 可以添加暂停功能（如果需要的话）\n          break;\n      }\n    }\n    \n    \/\/ 处理键盘释放事件\n    function handleKeyUp(e) {\n      keyPressed[e.code] = false;\n      \n      \/\/ 清除重复定时器\n      if (keyRepeatTimer[e.code]) {\n        clearTimeout(keyRepeatTimer[e.code]);\n        clearInterval(keyRepeatTimer[e.code]);\n        delete keyRepeatTimer[e.code];\n      }\n      \n      switch(e.code) {\n        case 'ArrowDown':\n          \/\/ 模拟释放下落按钮\n          if (isDownBtnPressed) {\n            isDownBtnPressed = false;\n            if (downBtnPressTimer) {\n              clearTimeout(downBtnPressTimer);\n              downBtnPressTimer = null;\n            }\n            stopFastDrop();\n          }\n          break;\n      }\n    }\n    \n    \/\/ 开始按键重复\n    function startKeyRepeat(keyCode, action) {\n      if (!keyPressed[keyCode]) return;\n      \n      keyRepeatTimer[keyCode] = setInterval(() => {\n        if (keyPressed[keyCode] && gameStarted && !gameOver) {\n          action();\n        } else {\n          clearInterval(keyRepeatTimer[keyCode]);\n          delete keyRepeatTimer[keyCode];\n        }\n      }, 100); \/\/ 每100ms重复一次\n    }\n    \n    \/\/ 显示键盘操作提示\n    function showKeyboardHints() {\n      \/\/ 创建提示元素\n      const hints = document.createElement('div');\n      hints.id = 'keyboardHints';\n      hints.style.cssText = `\n        position: fixed;\n        bottom: 20px;\n        left: 20px;\n        background: rgba(0, 0, 0, 0.8);\n        color: white;\n        padding: 15px;\n        border-radius: 10px;\n        font-size: 12px;\n        line-height: 1.5;\n        z-index: 100;\n        max-width: 200px;\n      `;\n      \n      hints.innerHTML = `\n        <div style=\"font-weight: bold; margin-bottom: 8px;\">键盘操作：<\/div>\n        <div>← → 左右移动<\/div>\n        <div>↓ 快速下落<\/div>\n        <div>↑ \/ 空格 旋转<\/div>\n        <div>Enter 开始游戏<\/div>\n        <div>R 重新开始<\/div>\n      `;\n      \n      document.body.appendChild(hints);\n      \n      \/\/ 5秒后自动隐藏\n      setTimeout(() => {\n        if (hints.parentNode) {\n          hints.parentNode.removeChild(hints);\n        }\n      }, 5000);\n    }\n    \n    \/\/ 处理下落按钮按下\n    function handleDownBtnPress(e) {\n      e.preventDefault();\n      \n      if (isDownBtnPressed) return; \/\/ 防止重复触发\n      \n      isDownBtnPressed = true;\n      \n      \/\/ 立即执行一次下落\n      playerDrop();\n      \n      \/\/ 设置1秒后开始快速下落的定时器\n      downBtnPressTimer = setTimeout(() => {\n        startFastDrop();\n      }, 1000);\n    }\n    \n    \/\/ 处理下落按钮释放\n    function handleDownBtnRelease(e) {\n      e.preventDefault();\n      \n      isDownBtnPressed = false;\n      \n      \/\/ 清除定时器\n      if (downBtnPressTimer) {\n        clearTimeout(downBtnPressTimer);\n        downBtnPressTimer = null;\n      }\n      \n      \/\/ 停止快速下落\n      stopFastDrop();\n    }\n\n    \/\/ 设置事件监听器\n    function setupEventListeners() {\n      \/\/ 键盘事件监听\n      document.addEventListener('keydown', handleKeyDown);\n      document.addEventListener('keyup', handleKeyUp);\n      \n      \/\/ 防止页面失去焦点时按键卡住\n      window.addEventListener('blur', () => {\n        keyPressed = {};\n        Object.keys(keyRepeatTimer).forEach(key => {\n          clearTimeout(keyRepeatTimer[key]);\n          clearInterval(keyRepeatTimer[key]);\n        });\n        keyRepeatTimer = {};\n        \n        \/\/ 停止下落相关操作\n        if (isDownBtnPressed) {\n          isDownBtnPressed = false;\n          if (downBtnPressTimer) {\n            clearTimeout(downBtnPressTimer);\n            downBtnPressTimer = null;\n          }\n          stopFastDrop();\n        }\n      });\n      \n      \/\/ 开始按钮\n      document.getElementById('startBtn').addEventListener('click', (e) => {\n        e.preventDefault();\n        startGame();\n      });\n      \n      document.getElementById('startBtn').addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        startGame();\n      });\n      \n      \/\/ 移动设备控制\n      document.getElementById('leftBtn').addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        playerMove(-1);\n      });\n      \n      document.getElementById('rightBtn').addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        playerMove(1);\n      });\n      \n      \/\/ 下落按钮的长按功能\n      const downBtn = document.getElementById('downBtn');\n      \n      \/\/ 触摸事件\n      downBtn.addEventListener('touchstart', handleDownBtnPress);\n      downBtn.addEventListener('touchend', handleDownBtnRelease);\n      downBtn.addEventListener('touchcancel', handleDownBtnRelease);\n      \n      \/\/ 鼠标事件（用于桌面测试）\n      downBtn.addEventListener('mousedown', handleDownBtnPress);\n      downBtn.addEventListener('mouseup', handleDownBtnRelease);\n      downBtn.addEventListener('mouseleave', handleDownBtnRelease);\n      \n      document.getElementById('rotateBtn').addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        playerRotate(1);\n      });\n      \n      document.getElementById('restartBtn').addEventListener('touchstart', (e) => {\n        e.preventDefault();\n        resetGame();\n      });\n      \n      \/\/ 添加鼠标事件支持（用于桌面测试）\n      document.getElementById('leftBtn').addEventListener('click', () => playerMove(-1));\n      document.getElementById('rightBtn').addEventListener('click', () => playerMove(1));\n      \/\/ 移除原来的downBtn点击事件，因为现在使用长按功能\n      document.getElementById('rotateBtn').addEventListener('click', () => playerRotate(1));\n      \n      document.getElementById('restartBtn').addEventListener('click', () => {\n        resetGame();\n      });\n      \n    }\n    \n    \/\/ 初始化游戏\n    window.addEventListener('DOMContentLoaded', init);\n  <\/script>\n<\/body>\n<\/html>",
    "type" : "game",
    "id" : "3b5e59dcfbd53300",
    "updatedAt" : "2025-08-02T12:20:18Z",
    "createdAt" : "2025-07-28T04:08:13Z",
    "desc" : "经典小游戏，你肯定玩过",
    "icon" : "gamecontroller",
    "color" : "orange",
    "version" : 1,
    "name" : "俄罗斯方块"
  }
]