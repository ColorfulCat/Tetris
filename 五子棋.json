[
  {
    "type" : "game",
    "color" : "brown",
    "isPinned" : false,
    "createdAt" : "2025-07-31T14:11:30Z",
    "icon" : "calendar",
    "id" : "9c4fb42129eb2df2",
    "name" : "五子棋",
    "desc" : "和简单AI一块玩会儿五子棋吧！",
    "version" : 1,
    "updatedAt" : "2025-08-02T12:20:18Z",
    "html" : "<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n  <title>五子棋<\/title>\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n      box-sizing: border-box;\n      touch-action: manipulation;\n      user-select: none;\n    }\n    \n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);\n      min-height: 100vh;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      color: white;\n      overflow-x: hidden;\n      position: relative;\n      padding: 10px;\n    }\n    \n    .game-container {\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      gap: 20px;\n      position: relative;\n      z-index: 10;\n      width: 100%;\n      max-width: 500px;\n    }\n    \n    .game-header {\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      width: 100%;\n      gap: 30px;\n      flex-wrap: wrap;\n    }\n    \n    .player-info {\n      background: rgba(0, 0, 0, 0.6);\n      border-radius: 20px;\n      padding: 20px 25px;\n      text-align: center;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);\n      flex: 1;\n      min-width: 140px;\n      max-width: 180px;\n      height: 130px;\n      transition: all 0.3s ease;\n      position: relative;\n      overflow: hidden;\n    }\n    \n    .player-info::before {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      height: 130px;\n      background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));\n      opacity: 0;\n      transition: opacity 0.3s ease;\n    }\n    \n    .player-info.active::before {\n      opacity: 1;\n      height: 130px;\n    }\n    \n    .player-info.active {\n      background: rgba(102, 126, 234, 0.8);\n      box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);\n      border: 2px solid rgba(255, 255, 255, 0.3);\n    }\n    \n    .player-name {\n      font-size: 16px;\n      color: #a0a0a0;\n      margin-bottom: 12px;\n      text-transform: uppercase;\n      letter-spacing: 2px;\n      font-weight: 600;\n    }\n    \n    .player-info.active .player-name {\n      color: #fff;\n      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n    }\n    \n    .player-piece-display {\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      gap: 10px;\n      margin-bottom: 8px;\n    }\n    \n    .player-piece {\n      width: 32px;\n      height: 32px;\n      border-radius: 50%;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);\n      transition: all 0.3s ease;\n    }\n    \n    .player-piece.white {\n      background: radial-gradient(circle at 30% 30%, #fff, #ddd);\n      border: 2px solid #ccc;\n    }\n    \n    .player-piece.black {\n      background: #000;\n      border: 2px solid #333;\n    }\n    \n    .player-info.active .player-piece {\n      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);\n    }\n    \n    .player-status {\n      font-size: 12px;\n      color: #888;\n      font-weight: 500;\n    }\n    \n    .player-info.active .player-status {\n      color: #fff;\n      font-weight: 600;\n    }\n    \n    .game-board-container {\n      background: rgba(0, 0, 0, 0.6);\n      border-radius: 15px;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);\n      padding: 15px;\n      position: relative;\n      width: 100%;\n      max-width: 450px;\n    }\n    \n    #gameBoard {\n      width: 100%;\n      aspect-ratio: 1;\n      background: rgba(139, 69, 19, 0.9);\n      border-radius: 8px;\n      position: relative;\n      padding: 20px;\n      cursor: pointer;\n    }\n    \n    .grid-line {\n      position: absolute;\n      background: rgba(0, 0, 0, 0.6);\n      z-index: 1;\n    }\n    \n    .grid-line.horizontal {\n      width: calc(100% - 40px);\n      height: 2px;\n      left: 20px;\n    }\n    \n    .grid-line.vertical {\n      width: 2px;\n      height: calc(100% - 40px);\n      top: 20px;\n    }\n    \n    .intersection {\n      position: absolute;\n      width: 30px;\n      height: 30px;\n      border-radius: 50%;\n      cursor: pointer;\n      z-index: 2;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      transition: all 0.2s ease;\n    }\n    \n    .intersection:hover {\n      background: rgba(255, 255, 255, 0.1);\n    }\n    \n    .piece {\n      width: 26px;\n      height: 26px;\n      border-radius: 50%;\n      position: absolute;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      transition: all 0.3s ease-in-out;\n      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);\n      animation: placepiece 0.3s ease-out;\n      z-index: 3;\n    }\n    \n    .piece.black {\n      background: #000;\n      border: 2px solid #333;\n    }\n    \n    .piece.white {\n      background: radial-gradient(circle at 30% 30%, #fff, #ddd);\n      border: 2px solid #ccc;\n    }\n    \n    .piece.winning {\n      animation: winning 1s ease-in-out infinite alternate;\n    }\n    \n    @keyframes placepiece {\n      0% {\n        opacity: 0;\n        transform: translate(-50%, -50%) scale(0);\n      }\n      100% {\n        opacity: 1;\n        transform: translate(-50%, -50%) scale(1);\n      }\n    }\n    \n    @keyframes winning {\n      0% {\n        box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);\n      }\n      100% {\n        box-shadow: 0 0 25px rgba(255, 215, 0, 1);\n      }\n    }\n    \n    .control-buttons {\n      display: flex;\n      gap: 15px;\n      flex-wrap: wrap;\n      justify-content: center;\n    }\n    \n    .game-btn {\n      padding: 15px 30px;\n      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n      border-radius: 25px;\n      font-size: 16px;\n      font-weight: bold;\n      color: white;\n      text-align: center;\n      box-shadow: \n        0 8px 25px rgba(102, 126, 234, 0.4),\n        inset 0 2px 4px rgba(255, 255, 255, 0.2);\n      transition: all 0.3s ease;\n      border: none;\n      cursor: pointer;\n      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n      position: relative;\n      overflow: hidden;\n      text-transform: uppercase;\n      letter-spacing: 1px;\n      min-width: 120px;\n    }\n    \n    .game-btn::before {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: -100%;\n      width: 100%;\n      height: 100%;\n      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);\n      transition: left 0.5s;\n    }\n    \n    .game-btn:hover {\n      transform: translateY(-3px);\n      box-shadow: \n        0 12px 35px rgba(102, 126, 234, 0.6),\n        inset 0 2px 4px rgba(255, 255, 255, 0.3);\n      background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);\n    }\n    \n    .game-btn:hover::before {\n      left: 100%;\n    }\n    \n    .game-btn:active {\n      transform: translateY(-1px) scale(0.98);\n    }\n    \n    .game-result {\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background: rgba(0, 0, 0, 0.85);\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n      z-index: 20;\n      display: none;\n    }\n    \n    .result-content {\n      background: rgba(0, 0, 0, 0.8);\n      border-radius: 20px;\n      padding: 40px;\n      text-align: center;\n      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);\n      max-width: 90%;\n    }\n    \n    .result-title {\n      font-size: 36px;\n      margin-bottom: 20px;\n      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);\n    }\n    \n    .result-title.win {\n      color: #50C878;\n    }\n    \n    .result-title.lose {\n      color: #ff4d4d;\n    }\n    \n    .result-title.draw {\n      color: #ffa500;\n    }\n    \n    .restart-btn {\n      padding: 18px 40px;\n      background: linear-gradient(to right, #ff416c, #ff4b2b);\n      border-radius: 30px;\n      font-size: 20px;\n      font-weight: bold;\n      color: white;\n      box-shadow: 0 8px 25px rgba(255, 75, 43, 0.4);\n      border: none;\n      cursor: pointer;\n      margin-top: 20px;\n      transition: all 0.3s ease;\n    }\n    \n    .restart-btn:hover {\n      transform: translateY(-2px);\n      box-shadow: 0 12px 35px rgba(255, 75, 43, 0.6);\n    }\n    \n    \/* 背景动画 *\/\n    .background {\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      overflow: hidden;\n      z-index: 1;\n    }\n    \n    .shape {\n      position: absolute;\n      background: rgba(255, 255, 255, 0.03);\n      border: 1px solid rgba(255, 255, 255, 0.05);\n      border-radius: 10px;\n      animation: float 15s infinite linear;\n    }\n    \n    @keyframes float {\n      0% {\n        transform: translateY(0) rotate(0deg);\n      }\n      100% {\n        transform: translateY(-100vh) rotate(360deg);\n      }\n    }\n    \n    \/* 响应式设计 *\/\n    @media (max-width: 480px) {\n      .game-container {\n        gap: 15px;\n        padding: 0 5px;\n      }\n      \n      .game-header {\n        gap: 20px;\n      }\n      \n      .player-info {\n        padding: 15px 20px;\n        min-width: 120px;\n      }\n      \n      .player-name {\n        font-size: 14px;\n      }\n      \n      .player-piece {\n        width: 28px;\n        height: 28px;\n      }\n      \n      .game-board-container {\n        padding: 10px;\n      }\n      \n      #gameBoard {\n        padding: 15px;\n      }\n      \n      .intersection {\n        width: 25px;\n        height: 25px;\n      }\n      \n      .piece {\n        width: 22px;\n        height: 22px;\n      }\n      \n      .game-btn {\n        padding: 12px 20px;\n        font-size: 14px;\n        min-width: 100px;\n      }\n      \n      .result-content {\n        padding: 30px 20px;\n      }\n      \n      .result-title {\n        font-size: 28px;\n      }\n    }\n  <\/style>\n<\/head>\n<body>\n  <div class=\"background\" id=\"background\"><\/div>\n  \n  <div class=\"game-container\">\n    <!-- 玩家信息 -->\n    <div class=\"game-header\">\n      <div class=\"player-info active\" id=\"playerInfo\">\n        <div class=\"player-name\">玩家<\/div>\n        <div class=\"player-piece-display\">\n          <div class=\"player-piece white\"><\/div>\n        <\/div>\n        <div class=\"player-status\">你的回合<\/div>\n      <\/div>\n      \n      <div class=\"player-info\" id=\"aiInfo\">\n        <div class=\"player-name\">AI<\/div>\n        <div class=\"player-piece-display\">\n          <div class=\"player-piece black\"><\/div>\n        <\/div>\n        <div class=\"player-status\">等待中...<\/div>\n      <\/div>\n    <\/div>\n    \n    <!-- 游戏棋盘 -->\n    <div class=\"game-board-container\">\n      <div id=\"gameBoard\"><\/div>\n    <\/div>\n    \n    <!-- 控制按钮 -->\n    <div class=\"control-buttons\">\n      <button class=\"game-btn\" id=\"newGameBtn\">新游戏<\/button>\n    <\/div>\n  <\/div>\n  \n  <!-- 游戏结果弹窗 -->\n  <div class=\"game-result\" id=\"gameResult\">\n    <div class=\"result-content\">\n      <div class=\"result-title\" id=\"resultTitle\">游戏结束<\/div>\n      <button class=\"restart-btn\" id=\"restartBtn\">重新开始<\/button>\n    <\/div>\n  <\/div>\n\n  <script>\n    \/\/ 游戏状态\n    const BOARD_SIZE = 15;\n    const EMPTY = 0;\n    const PLAYER = 1;\n    const AI = 2;\n    \n    let board = [];\n    let currentPlayer = PLAYER;\n    let gameEnded = false;\n    let moveHistory = [];\n    let cellSize = 0;\n    \n    \/\/ AI难度设置\n    const AI_DEPTH = 4;\n    \n    \/\/ 智能评分系统\n    const SCORES = {\n      FIVE: 1000000,        \/\/ 连五\n      LIVE_FOUR: 100000,    \/\/ 活四\n      RUSH_FOUR: 50000,     \/\/ 冲四\n      LIVE_THREE: 10000,    \/\/ 活三\n      SLEEP_THREE: 1000,    \/\/ 眠三\n      LIVE_TWO: 500,        \/\/ 活二\n      SLEEP_TWO: 50,        \/\/ 眠二\n      ONE: 10               \/\/ 单子\n    };\n    \n    \/\/ 初始化游戏\n    function init() {\n      createBackground();\n      setupEventListeners();\n      newGame();\n    }\n    \n    \/\/ 创建动态背景\n    function createBackground() {\n      const bg = document.getElementById('background');\n      const colors = ['rgba(255,255,255,0.05)', 'rgba(255,255,255,0.03)', 'rgba(255,255,255,0.02)'];\n      \n      for (let i = 0; i < 20; i++) {\n        const shape = document.createElement('div');\n        shape.classList.add('shape');\n        \n        const size = Math.random() * 100 + 50;\n        shape.style.width = `${size}px`;\n        shape.style.height = `${size}px`;\n        shape.style.left = `${Math.random() * 100}%`;\n        shape.style.top = `${Math.random() * 100}%`;\n        shape.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];\n        shape.style.animationDuration = `${Math.random() * 30 + 15}s`;\n        shape.style.animationDelay = `${Math.random() * 5}s`;\n        \n        bg.appendChild(shape);\n      }\n    }\n    \n    \/\/ 设置事件监听器\n    function setupEventListeners() {\n      document.getElementById('newGameBtn').addEventListener('click', newGame);\n      document.getElementById('restartBtn').addEventListener('click', newGame);\n      \n      \/\/ 窗口大小改变时重新创建棋盘\n      window.addEventListener('resize', () => {\n        setTimeout(createBoard, 100);\n      });\n    }\n    \n    \/\/ 新游戏\n    function newGame() {\n      \/\/ 初始化棋盘\n      board = [];\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        board[i] = [];\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          board[i][j] = EMPTY;\n        }\n      }\n      \n      currentPlayer = PLAYER;\n      gameEnded = false;\n      moveHistory = [];\n      \n      createBoard();\n      updatePlayerInfo();\n      document.getElementById('gameResult').style.display = 'none';\n    }\n    \n    \/\/ 创建棋盘\n    function createBoard() {\n      const gameBoard = document.getElementById('gameBoard');\n      gameBoard.innerHTML = '';\n      \n      \/\/ 等待DOM更新后获取尺寸\n      setTimeout(() => {\n        const boardRect = gameBoard.getBoundingClientRect();\n        \n        \/\/ 动态获取当前的padding和intersection尺寸\n        const computedStyle = window.getComputedStyle(gameBoard);\n        const boardPadding = parseInt(computedStyle.paddingLeft);\n        \n        const intersectionStyle = window.getComputedStyle(document.querySelector('.intersection') || document.createElement('div'));\n        const intersectionSize = parseInt(intersectionStyle.width) || (window.innerWidth <= 480 ? 25 : 30);\n        const intersectionRadius = intersectionSize \/ 2;\n        \n        cellSize = (boardRect.width - boardPadding * 2) \/ (BOARD_SIZE - 1);\n        \n        \/\/ 创建网格线\n        for (let i = 0; i < BOARD_SIZE; i++) {\n          \/\/ 水平线\n          const hLine = document.createElement('div');\n          hLine.className = 'grid-line horizontal';\n          hLine.style.top = `${boardPadding + i * cellSize}px`;\n          gameBoard.appendChild(hLine);\n          \n          \/\/ 垂直线\n          const vLine = document.createElement('div');\n          vLine.className = 'grid-line vertical';\n          vLine.style.left = `${boardPadding + i * cellSize}px`;\n          gameBoard.appendChild(vLine);\n        }\n        \n        \/\/ 创建交叉点 - 精确对齐到网格线交叉点\n        for (let i = 0; i < BOARD_SIZE; i++) {\n          for (let j = 0; j < BOARD_SIZE; j++) {\n            const intersection = document.createElement('div');\n            intersection.className = 'intersection';\n            intersection.dataset.row = i;\n            intersection.dataset.col = j;\n            \/\/ 交叉点中心对齐到网格线交叉点 - 使用动态计算的值\n            intersection.style.left = `${boardPadding + j * cellSize - intersectionRadius}px`;\n            intersection.style.top = `${boardPadding + i * cellSize - intersectionRadius}px`;\n            intersection.addEventListener('click', () => handleIntersectionClick(i, j));\n            gameBoard.appendChild(intersection);\n          }\n        }\n        \n        \/\/ 重新渲染已有的棋子\n        updateBoard();\n      }, 50);\n    }\n    \n    \/\/ 处理交叉点点击\n    function handleIntersectionClick(row, col) {\n      if (gameEnded || currentPlayer !== PLAYER || board[row][col] !== EMPTY) {\n        return;\n      }\n      \n      makeMove(row, col, PLAYER);\n      \n      if (!gameEnded) {\n        setTimeout(() => {\n          aiMove();\n        }, 300);\n      }\n    }\n    \n    \/\/ 下棋\n    function makeMove(row, col, player) {\n      board[row][col] = player;\n      moveHistory.push({row, col, player});\n      \n      updateBoard();\n      \n      if (checkWin(row, col, player)) {\n        endGame(player);\n        return;\n      }\n      \n      if (isBoardFull()) {\n        endGame(0); \/\/ 平局\n        return;\n      }\n      \n      currentPlayer = currentPlayer === PLAYER ? AI : PLAYER;\n      updatePlayerInfo();\n    }\n    \n    \/\/ AI下棋 - 智能防守算法\n    function aiMove() {\n      if (gameEnded || currentPlayer !== AI) return;\n      \n      const move = getBestMove();\n      if (move) {\n        makeMove(move.row, move.col, AI);\n      }\n    }\n    \n    \/\/ 获取最佳移动 - 智能算法\n    function getBestMove() {\n      \/\/ 1. 检查AI是否有必胜位置\n      const winMove = findWinningMove(AI);\n      if (winMove) return winMove;\n      \n      \/\/ 2. 检查是否需要防守玩家的必胜位置\n      const blockMove = findWinningMove(PLAYER);\n      if (blockMove) return blockMove;\n      \n      \/\/ 3. 检查AI的活四位置\n      const aiFourMove = findPatternMove(AI, SCORES.LIVE_FOUR);\n      if (aiFourMove) return aiFourMove;\n      \n      \/\/ 4. 检查需要防守的玩家活四位置\n      const blockFourMove = findPatternMove(PLAYER, SCORES.LIVE_FOUR);\n      if (blockFourMove) return blockFourMove;\n      \n      \/\/ 5. 检查AI的活三位置\n      const aiThreeMove = findPatternMove(AI, SCORES.LIVE_THREE);\n      if (aiThreeMove) return aiThreeMove;\n      \n      \/\/ 6. 检查需要防守的玩家活三位置\n      const blockThreeMove = findPatternMove(PLAYER, SCORES.LIVE_THREE);\n      if (blockThreeMove) return blockThreeMove;\n      \n      \/\/ 7. 如果是第一步，下在中心\n      if (moveHistory.length === 0) {\n        return {row: Math.floor(BOARD_SIZE \/ 2), col: Math.floor(BOARD_SIZE \/ 2)};\n      }\n      \n      \/\/ 8. 使用Minimax算法寻找最佳位置\n      return minimaxSearch();\n    }\n    \n    \/\/ Minimax搜索\n    function minimaxSearch() {\n      const candidates = getCandidateMoves();\n      let bestScore = -Infinity;\n      let bestMove = null;\n      \n      for (const move of candidates) {\n        board[move.row][move.col] = AI;\n        const score = minimax(AI_DEPTH - 1, -Infinity, Infinity, false);\n        board[move.row][move.col] = EMPTY;\n        \n        if (score > bestScore) {\n          bestScore = score;\n          bestMove = move;\n        }\n      }\n      \n      return bestMove || candidates[0];\n    }\n    \n    \/\/ Minimax算法\n    function minimax(depth, alpha, beta, isMaximizing) {\n      if (depth === 0) {\n        return evaluateBoard();\n      }\n      \n      const moves = getCandidateMoves();\n      \n      if (isMaximizing) {\n        let maxScore = -Infinity;\n        for (const move of moves) {\n          board[move.row][move.col] = AI;\n          \n          if (checkWin(move.row, move.col, AI)) {\n            board[move.row][move.col] = EMPTY;\n            return SCORES.FIVE + depth;\n          }\n          \n          const score = minimax(depth - 1, alpha, beta, false);\n          board[move.row][move.col] = EMPTY;\n          \n          maxScore = Math.max(score, maxScore);\n          alpha = Math.max(alpha, score);\n          if (beta <= alpha) break;\n        }\n        return maxScore;\n      } else {\n        let minScore = Infinity;\n        for (const move of moves) {\n          board[move.row][move.col] = PLAYER;\n          \n          if (checkWin(move.row, move.col, PLAYER)) {\n            board[move.row][move.col] = EMPTY;\n            return -SCORES.FIVE - depth;\n          }\n          \n          const score = minimax(depth - 1, alpha, beta, true);\n          board[move.row][move.col] = EMPTY;\n          \n          minScore = Math.min(score, minScore);\n          beta = Math.min(beta, score);\n          if (beta <= alpha) break;\n        }\n        return minScore;\n      }\n    }\n    \n    \/\/ 寻找获胜位置\n    function findWinningMove(player) {\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          if (board[i][j] === EMPTY) {\n            board[i][j] = player;\n            if (checkWin(i, j, player)) {\n              board[i][j] = EMPTY;\n              return {row: i, col: j};\n            }\n            board[i][j] = EMPTY;\n          }\n        }\n      }\n      return null;\n    }\n    \n    \/\/ 寻找特定模式的位置\n    function findPatternMove(player, targetScore) {\n      const candidates = getCandidateMoves();\n      \n      for (const move of candidates) {\n        const score = evaluatePosition(move.row, move.col, player);\n        if (score >= targetScore) {\n          return move;\n        }\n      }\n      return null;\n    }\n    \n    \/\/ 获取候选移动位置\n    function getCandidateMoves() {\n      const moves = [];\n      const range = 2;\n      const checked = new Set();\n      \n      \/\/ 在已有棋子周围寻找候选位置\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          if (board[i][j] !== EMPTY) {\n            for (let di = -range; di <= range; di++) {\n              for (let dj = -range; dj <= range; dj++) {\n                const ni = i + di;\n                const nj = j + dj;\n                const key = `${ni},${nj}`;\n                \n                if (ni >= 0 && ni < BOARD_SIZE && \n                    nj >= 0 && nj < BOARD_SIZE && \n                    board[ni][nj] === EMPTY && \n                    !checked.has(key)) {\n                  moves.push({row: ni, col: nj});\n                  checked.add(key);\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      \/\/ 如果没有候选位置，返回中心附近的位置\n      if (moves.length === 0) {\n        const center = Math.floor(BOARD_SIZE \/ 2);\n        for (let i = center - 1; i <= center + 1; i++) {\n          for (let j = center - 1; j <= center + 1; j++) {\n            if (i >= 0 && i < BOARD_SIZE && j >= 0 && j < BOARD_SIZE && board[i][j] === EMPTY) {\n              moves.push({row: i, col: j});\n            }\n          }\n        }\n      }\n      \n      \/\/ 按评分排序，优先考虑高分位置\n      moves.sort((a, b) => {\n        const scoreA = evaluatePosition(a.row, a.col, AI) + evaluatePosition(a.row, a.col, PLAYER);\n        const scoreB = evaluatePosition(b.row, b.col, AI) + evaluatePosition(b.row, b.col, PLAYER);\n        return scoreB - scoreA;\n      });\n      \n      return moves.slice(0, 15); \/\/ 限制候选数量\n    }\n    \n    \/\/ 评估棋盘\n    function evaluateBoard() {\n      let score = 0;\n      \n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          if (board[i][j] === AI) {\n            score += evaluatePosition(i, j, AI);\n          } else if (board[i][j] === PLAYER) {\n            score -= evaluatePosition(i, j, PLAYER) * 1.1; \/\/ 稍微提高防守权重\n          }\n        }\n      }\n      \n      return score;\n    }\n    \n    \/\/ 评估位置得分\n    function evaluatePosition(row, col, player) {\n      let totalScore = 0;\n      const directions = [\n        [0, 1],   \/\/ 水平\n        [1, 0],   \/\/ 垂直\n        [1, 1],   \/\/ 对角线\n        [1, -1]   \/\/ 反对角线\n      ];\n      \n      for (const [dr, dc] of directions) {\n        totalScore += evaluateDirection(row, col, dr, dc, player);\n      }\n      \n      return totalScore;\n    }\n    \n    \/\/ 评估方向得分 - 智能模式识别\n    function evaluateDirection(row, col, dr, dc, player) {\n      const line = getLine(row, col, dr, dc);\n      return analyzePattern(line, player);\n    }\n    \n    \/\/ 获取直线上的棋子情况\n    function getLine(row, col, dr, dc) {\n      const line = [];\n      \n      \/\/ 向前扫描4个位置\n      for (let i = -4; i <= 4; i++) {\n        const r = row + i * dr;\n        const c = col + i * dc;\n        \n        if (r < 0 || r >= BOARD_SIZE || c < 0 || c >= BOARD_SIZE) {\n          line.push('X'); \/\/ 边界\n        } else {\n          line.push(board[r][c]);\n        }\n      }\n      \n      return line;\n    }\n    \n    \/\/ 分析棋型模式\n    function analyzePattern(line, player) {\n      const opponent = player === AI ? PLAYER : AI;\n      let score = 0;\n      \n      \/\/ 将当前位置设为该玩家的棋子\n      line[4] = player;\n      \n      \/\/ 转换为字符串便于模式匹配\n      const pattern = line.map(cell => {\n        if (cell === player) return 'O';\n        if (cell === opponent) return 'X';\n        if (cell === EMPTY) return '_';\n        return 'B'; \/\/ 边界\n      }).join('');\n      \n      \/\/ 连五\n      if (pattern.includes('OOOOO')) {\n        score += SCORES.FIVE;\n      }\n      \n      \/\/ 活四\n      if (pattern.includes('_OOOO_')) {\n        score += SCORES.LIVE_FOUR;\n      }\n      \n      \/\/ 冲四\n      if (pattern.includes('XOOOO_') || pattern.includes('_OOOOX') || \n          pattern.includes('BOOOO_') || pattern.includes('_OOOOB')) {\n        score += SCORES.RUSH_FOUR;\n      }\n      \n      \/\/ 活三\n      if (pattern.includes('_OOO_') || pattern.includes('_O_OO_') || pattern.includes('_OO_O_')) {\n        score += SCORES.LIVE_THREE;\n      }\n      \n      \/\/ 眠三\n      if (pattern.includes('XOOO_') || pattern.includes('_OOOX') ||\n          pattern.includes('XOO_O') || pattern.includes('O_OOX') ||\n          pattern.includes('BOOO_') || pattern.includes('_OOOB')) {\n        score += SCORES.SLEEP_THREE;\n      }\n      \n      \/\/ 活二\n      if (pattern.includes('_OO_') || pattern.includes('_O_O_')) {\n        score += SCORES.LIVE_TWO;\n      }\n      \n      \/\/ 眠二\n      if (pattern.includes('XOO_') || pattern.includes('_OOXX') ||\n          pattern.includes('XO_O') || pattern.includes('O_OX') ||\n          pattern.includes('BOO_') || pattern.includes('_OOBB')) {\n        score += SCORES.SLEEP_TWO;\n      }\n      \n      \/\/ 单子\n      if (pattern.includes('_O_')) {\n        score += SCORES.ONE;\n      }\n      \n      return score;\n    }\n    \n    \/\/ 检查获胜\n    function checkWin(row, col, player) {\n      const directions = [\n        [0, 1],   \/\/ 水平\n        [1, 0],   \/\/ 垂直\n        [1, 1],   \/\/ 对角线\n        [1, -1]   \/\/ 反对角线\n      ];\n      \n      for (const [dr, dc] of directions) {\n        let count = 1;\n        \n        \/\/ 向前计数\n        let r = row + dr;\n        let c = col + dc;\n        while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {\n          count++;\n          r += dr;\n          c += dc;\n        }\n        \n        \/\/ 向后计数\n        r = row - dr;\n        c = col - dc;\n        while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {\n          count++;\n          r -= dr;\n          c -= dc;\n        }\n        \n        if (count >= 5) {\n          highlightWinningPieces(row, col, dr, dc, player);\n          return true;\n        }\n      }\n      \n      return false;\n    }\n    \n    \/\/ 高亮获胜棋子\n    function highlightWinningPieces(row, col, dr, dc, player) {\n      const pieces = [{row, col}];\n      \n      \/\/ 向前收集\n      let r = row + dr;\n      let c = col + dc;\n      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {\n        pieces.push({row: r, col: c});\n        r += dr;\n        c += dc;\n      }\n      \n      \/\/ 向后收集\n      r = row - dr;\n      c = col - dc;\n      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {\n        pieces.push({row: r, col: c});\n        r -= dr;\n        c -= dc;\n      }\n      \n      \/\/ 高亮前5个棋子\n      for (let i = 0; i < Math.min(5, pieces.length); i++) {\n        const piece = pieces[i];\n        const pieceElement = document.querySelector(`[data-row=\"${piece.row}\"][data-col=\"${piece.col}\"] .piece`);\n        if (pieceElement) {\n          pieceElement.classList.add('winning');\n        }\n      }\n    }\n    \n    \/\/ 检查棋盘是否满了\n    function isBoardFull() {\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          if (board[i][j] === EMPTY) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    \n    \/\/ 更新棋盘显示\n    function updateBoard() {\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          const intersection = document.querySelector(`[data-row=\"${i}\"][data-col=\"${j}\"]`);\n          if (!intersection) continue;\n          \n          const existingPiece = intersection.querySelector('.piece');\n          \n          if (board[i][j] !== EMPTY && !existingPiece) {\n            const piece = document.createElement('div');\n            piece.className = `piece ${board[i][j] === PLAYER ? 'white' : 'black'}`;\n            intersection.appendChild(piece);\n          } else if (board[i][j] === EMPTY && existingPiece) {\n            existingPiece.remove();\n          }\n        }\n      }\n    }\n    \n    \/\/ 更新玩家信息\n    function updatePlayerInfo() {\n      const playerInfo = document.getElementById('playerInfo');\n      const aiInfo = document.getElementById('aiInfo');\n      const playerStatus = playerInfo.querySelector('.player-status');\n      const aiStatus = aiInfo.querySelector('.player-status');\n      \n      if (currentPlayer === PLAYER) {\n        playerInfo.classList.add('active');\n        aiInfo.classList.remove('active');\n        playerStatus.textContent = '你的回合';\n        aiStatus.textContent = '等待中...';\n      } else {\n        playerInfo.classList.remove('active');\n        aiInfo.classList.add('active');\n        playerStatus.textContent = '等待中...';\n        aiStatus.textContent = 'AI思考中...';\n      }\n    }\n    \n    \/\/ 结束游戏\n    function endGame(winner) {\n      gameEnded = true;\n      const resultTitle = document.getElementById('resultTitle');\n      \n      if (winner === PLAYER) {\n        resultTitle.textContent = '恭喜！你赢了！';\n        resultTitle.className = 'result-title win';\n      } else if (winner === AI) {\n        resultTitle.textContent = 'AI获胜！';\n        resultTitle.className = 'result-title lose';\n      } else {\n        resultTitle.textContent = '平局！';\n        resultTitle.className = 'result-title draw';\n      }\n      \n      \/\/ 更新状态显示\n      const playerStatus = document.getElementById('playerInfo').querySelector('.player-status');\n      const aiStatus = document.getElementById('aiInfo').querySelector('.player-status');\n      \n      if (winner === PLAYER) {\n        playerStatus.textContent = '获胜！';\n        aiStatus.textContent = '失败';\n      } else if (winner === AI) {\n        playerStatus.textContent = '失败';\n        aiStatus.textContent = '获胜！';\n      } else {\n        playerStatus.textContent = '平局';\n        aiStatus.textContent = '平局';\n      }\n      \n      setTimeout(() => {\n        document.getElementById('gameResult').style.display = 'flex';\n      }, 1000);\n    }\n    \n    \/\/ 页面加载完成后初始化\n    document.addEventListener('DOMContentLoaded', init);\n  <\/script>\n<\/body>\n<\/html>"
  }
]